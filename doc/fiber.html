<HTML>
<link rel="stylesheet" type="text/css" href="mystylesheet.css"/>
<HEAD>
<TITLE>Class fiber</TITLE>
</HEAD>
<BODY>
<H1><A NAME="top">Class fiber in "fiber.h"</A></H1>
<P> <a href="">back</a>
<hr/>
<DL>
<DT>Superclass
<DD><A HREF="volumeshape.html">volumeShape</A>
<DT>Constructor
<LI><A HREF="#c2">fiber</A>(<A HREF="point3d.html">point3D</A> cor = point3D(0,0,0), <A HREF="vector3d.html">vector3D</A> d1 = vector3D(1,0,0), <A HREF="vector3d.html">vector3D</A> d2 = vector3D(0,1,0), <A HREF="vector3d.html">vector3D</A> d3 = vector3D(0,0,1), <vtype>int</vtype> halved = 0, <vtype>int</vtype> halvedat = 0) 
<LI><A HREF="#c3">fiber</A>(const <A HREF="volumeshape.html">volumeShape&</A> s) 
<LI><A HREF="#c4">fiber</A>(const <A HREF="fiber.html">fiber&</A> s) 
<LI><A HREF="#c5">fiber</A>(const <A HREF="shapeparameter.html">shape_parameter&</A> description) 
<DT>Functions
<DD>new public<ul>
<LI>virtual <A HREF="point3d.html">point3D</A> <A HREF="#f2">getCorner</A>() const
<LI>virtual <A HREF="vector3d.html">vector3D</A> <A HREF="#f3">getDirection</A>(<vtype>int</vtype> num) const
<LI><A HREF="#f4"><vtype>void</vtype> setCorner</A>(<A HREF="point3d.html">point3D</A> p) 
<LI><A HREF="#f5"><vtype>void</vtype> setDirection</A>(<vtype>int</vtype> num, <A HREF="vector3d.html">vector3D</A> v) 
<LI><A HREF="#f6"><vtype>int</vtype> getHalved</A>() const
<LI><A HREF="#f7"><vtype>void</vtype> setHalved</A>(<vtype>int</vtype> num) 
<LI><A HREF="#f8"><vtype>int</vtype> getHalvedAt</A>() const
<LI><A HREF="#f9"><vtype>void</vtype> setHalvedAt</A>(<vtype>int</vtype> num) 
<LI>virtual <A HREF="#f16"><vtype>void</vtype> operator=</A>(const <A HREF="volumeshape.html">volumeShape&</A> s) 
<LI>virtual <A HREF="shapeparameter.html">shape_parameter</A> <A HREF="#f25">description</A>() const
</UL>
<DD>static<ul>
<LI>static <A HREF="shapeparameter.html">shape_parameter</A> <A HREF="#f26">getDescription</A>() 
</UL>
<DD>public overwritten inherrited<UL>
<LI>virtual <A HREF="#f21"><vtype>float</vtype> getFlightPathInShape</A>(const <A HREF="sline3d.html">sLine3D&</A> line) 
<LI>virtual <A HREF="volumeshape.html">volumeShape*</A> <A HREF="#f17">getClone</A>() 
<LI>virtual <A HREF="vector.html">Vector</A> <A HREF="#f18">HitParams</A>(const <A HREF="sline3d.html">sLine3D&</A> line) 
<LI>virtual <A HREF="vector.html">Vector</A> <A HREF="#f14">Hitting</A>(const <A HREF="sline3d.html">sLine3D&</A> line) 
<LI>virtual <A HREF="vector.html">Vector</A> <A HREF="#f19">HitParams</A>(const <A HREF="planeshape.html">planeShape&</A> shape, <A HREF="point3d.html">point3D</A> origin) 
<LI>virtual <A HREF="volumeshape.html">volumeShape*</A> <A HREF="#f10">getNext</A>(<vtype>int</vtype> times, <vtype>int</vtype> stackType) 
<LI>virtual <A HREF="volumeshape.html">volumeShape*</A> <A HREF="#f11">getEnvelope</A>(<vtype>int</vtype> times, <vtype>int</vtype> stackType) 
<LI>virtual <A HREF="#f22"><vtype>int</vtype> suspect</A>(const <A HREF="sline3d.html">sLine3D&</A> line, <vtype>int</vtype> stackType) 
<LI>virtual <A HREF="point3d.html">point3D</A> <A HREF="#f20">entrance</A>(const <A HREF="sline3d.html">sLine3D&</A> line) 
<LI>virtual <A HREF="vector3d.html">vector3D</A> <A HREF="#f12">distance</A>(const <A HREF="sline3d.html">sLine3D&</A> line) 
<LI>virtual <A HREF="sline3d.html">sLine3D</A> <A HREF="#f13">Normal</A>(const <A HREF="sline3d.html">sLine3D&</A> line) 
<LI>virtual <A HREF="#f15"><vtype>bool</vtype> cut</A>(const <A HREF="fiber.html">fiber&</A> f) 
<LI>virtual <A HREF="vector.html">Vector</A> <A HREF="#f18">HitParams</A>(const <A HREF="sline3d.html">sLine3D&</A> line) 
<LI>virtual <A HREF="#f23"><vtype>void</vtype> Draw</A>(const <A HREF="point3d.html">point3D&</A> eye, const <A HREF="plane3d.html">plane3D&</A> plane, <A HREF="vector4d.html">vector4D*</A> boundingBox, <vtype>int</vtype> lColor, <vtype>int</vtype> fColor = 8, <vtype>int</vtype> fStyle = 1001) const
<LI>virtual <A HREF="#f24"><vtype>void</vtype> Draw</A>(const <A HREF="point3d.html">point3D&</A> eye = point3D(0,0,0), const <A HREF="plane3d.html">plane3D&</A> plane = plane3D(point3D(0,0,1),vector3D(0,0,1)), <A HREF="vector4d.html">vector4D*</A> boundingBox = NULL, <A HREF="tobject.html">TObject**</A> ident = NULL, <vtype>int</vtype> lColor = 1, <vtype>int</vtype> fColor = 8, <vtype>int</vtype> fStyle = 1001) const
</UL>
<DD>public inherrited<UL>
<LI><A HREF="volumeshape.html#f3"><vtype>float</vtype> volumeShape::getMaxDistance</A>() const
<LI><A HREF="volumeshape.html#f4"><vtype>void</vtype> volumeShape::setMaxDistance</A>(<vtype>float</vtype> value) 
<LI><A HREF="http://doc.trolltech.com/4.4/qstring.html">QString</A> <A HREF="baseshape.html#f2">base_shape::getName</A>() const
<LI><A HREF="point3d.html">point3D</A> <A HREF="baseshape.html#f3">base_shape::getCenter</A>() const
<LI><A HREF="baseshape.html#f4"><vtype>void</vtype> base_shape::setCenter</A>(<A HREF="point3d.html">point3D</A> c) 
<LI><A HREF="baseparameter.html#f3"><vtype>void</vtype> base_parameter::setName</A>(const <vtype>string&</vtype> n) 
<LI><A HREF="baseparameter.html#f4"><vtype>void</vtype> base_parameter::setDescription</A>(<vtype>vector&lt;string&gt;</vtype> d) 
<LI><A HREF="baseparameter.html#f5"><vtype>void</vtype> base_parameter::setDescription</A>(const <vtype>string&</vtype> d, <vtype>int</vtype> line) 
<LI><A HREF="baseparameter.html#f6"><vtype>string</vtype> base_parameter::getName</A>() const
<LI><A HREF="baseparameter.html#f7"><vtype>string</vtype> base_parameter::getDescription</A>(<vtype>int</vtype> line) const
<LI><A HREF="baseparameter.html#f8"><vtype>vector&lt;string&gt;</vtype> base_parameter::getDescription</A>() const
<LI><A HREF="baseparameter.html#f9"><vtype>bool</vtype> base_parameter::operator<</A>(<A HREF="baseparameter.html">base_parameter</A> p) 
<LI><A HREF="baseparameter.html#f10"><vtype>bool</vtype> base_parameter::operator></A>(<A HREF="baseparameter.html">base_parameter</A> p) 
<LI><A HREF="baseparameter.html#f11"><vtype>bool</vtype> base_parameter::operator==</A>(<A HREF="baseparameter.html">base_parameter</A> p) 
<LI><A HREF="baseparameter.html#f12"><vtype>bool</vtype> base_parameter::operator<=</A>(<A HREF="baseparameter.html">base_parameter</A> p) 
<LI><A HREF="baseparameter.html#f13"><vtype>bool</vtype> base_parameter::operator>=</A>(<A HREF="baseparameter.html">base_parameter</A> p) 
</UL>
<DT>Protected Variables
<DD><A HREF="point3d.html">point3D</A> <A HREF="#v2">corner</A>
<DD><A HREF="vector3d.html">vector3D</A> <A HREF="#v3">dir1</A>
<DD><A HREF="vector3d.html">vector3D</A> <A HREF="#v4">dir2</A>
<DD><A HREF="vector3d.html">vector3D</A> <A HREF="#v5">dir3</A>
<DD><vtype>int</vtype> <A HREF="#v6">numberOfHalvedElements</A>
<DD><vtype>int</vtype> <A HREF="#v7">halvedAt</A>
<DT>Protected inherrited variables
<DD><A HREF="vector3d.html">vector3D</A> <A HREF="volumeshape.html#v2">volumeShape::res</A>
<DD><A HREF="point3d.html">point3D</A> <A HREF="baseshape.html#v2">base_shape::center</A>
</DL>
<hr/>
<H2>Descriptions</H2>
<UL TYPE=square>
<li>
<A NAME="c2">fiber::fiber</A>(<A HREF="point3d.html">point3D</A> cor = point3D(0,0,0), <A HREF="vector3d.html">vector3D</A> d1 = vector3D(1,0,0), <A HREF="vector3d.html">vector3D</A> d2 = vector3D(0,1,0), <A HREF="vector3d.html">vector3D</A> d3 = vector3D(0,0,1), <vtype>int</vtype> halved = 0, <vtype>int</vtype> halvedat = 0) 
<BR/><deff>
Constructor. Sets a fiber. <var>cor</var> is one of the corner points and with the three vectors <var>d1</var>, <var>d2</var> and <var>d3</var> it defines a volume with any two opposing areas being parallel. 
The properties <var>halved</var> and <var>halved at</var> are for stacking purposes and define in a stack of n fibers the number of fibers that are half the size of the other fibers (a second fiber is then filling up the space) and the element number when the halved elements first occur. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="c3">fiber::fiber</A>(const <A HREF="volumeshape.html">volumeShape&</A> s) 
<BR/><deff>
Copy constructor. Works only if the shape is a fiber. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="c4">fiber::fiber</A>(const <A HREF="fiber.html">fiber&</A> s) 
<BR/><deff>
Copy constructor. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="c5">fiber::fiber</A>(const <A HREF="shapeparameter.html">shape_parameter&</A> description) 
<BR/><deff>
Constructor. Creates a fiber with the values from the parameter.
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A HREF="point3d.html">point3D</A> <A NAME="#v2">corner</A>
<BR/><deff>
The corner of the fiber. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A HREF="vector3d.html">vector3D</A> <A NAME="#v3">dir1</A>
<BR/><deff>
One of the three direction vectors a fiber defines. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A HREF="vector3d.html">vector3D</A> <A NAME="#v4">dir2</A>
<BR/><deff>
One of the three direction vectors a fiber defines. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A HREF="vector3d.html">vector3D</A> <A NAME="#v5">dir3</A>
<BR/><deff>
One of the three direction vectors a fiber defines. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="#v6">int numberOfHalvedElements</A>
<BR/><deff>
The properties <var>halved</var> and <var>halved at</var> are for stacking purposes and define in a stack of n fibers the number of fibers that are half the size of the other fibers (a second fiber is then filling up the space) and the element number when the halved elements first occur.  
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="#v7">int halvedAt</A>
<BR/><deff>
The properties <var>halved</var> and <var>halved at</var> are for stacking purposes and define in a stack of n fibers the number of fibers that are half the size of the other fibers (a second fiber is then filling up the space) and the element number when the halved elements first occur.  
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A HREF="point3d.html">point3D</A> <A NAME="f2">fiber::getCorner</A>() const
<BR/><deff>
Returns the corner of the fiber. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A HREF="vector3d.html">vector3D</A> <A NAME="f3">fiber::getDirection</A>(<vtype>int</vtype> num) const
<BR/><deff>
Returns the <var>num<sup>th</sup></var> direction vector of the fiber. Returns an undefined vector if <var>num</var> is non valid. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f4"><vtype>void</vtype> fiber::setCorner</A>(<A HREF="point3d.html">point3D</A> p) 
<BR/><deff>
Sets the corner of the fiber. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f5"><vtype>void</vtype> fiber::setDirection</A>(<vtype>int</vtype> num, <A HREF="vector3d.html">vector3D</A> v) 
<BR/><deff>
Sets the <var>num<sup>th</sup></var> direction vector. Does nothing if <var>num</var> is non valid. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f6"><vtype>int</vtype> fiber::getHalved</A>() const
<BR/><deff>
Returns the halved property. 
The properties <var>halved</var> and <var>halved at</var> are for stacking purposes and define in a stack of n fibers the number of fibers that are half the size of the other fibers (a second fiber is then filling up the space) and the element number when the halved elements first occur.  
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f7"><vtype>void</vtype> fiber::setHalved</A>(<vtype>int</vtype> num) 
<BR/><deff>
Sets the halved property. 
The properties <var>halved</var> and <var>halved at</var> are for stacking purposes and define in a stack of n fibers the number of fibers that are half the size of the other fibers (a second fiber is then filling up the space) and the element number when the halved elements first occur.  
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f8"><vtype>int</vtype> fiber::getHalvedAt</A>() const
<BR/><deff>
Returns the halved at property. 
The properties <var>halved</var> and <var>halved at</var> are for stacking purposes and define in a stack of n fibers the number of fibers that are half the size of the other fibers (a second fiber is then filling up the space) and the element number when the halved elements first occur.  
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f9"><vtype>void</vtype> fiber::setHalvedAt</A>(<vtype>int</vtype> num) 
<BR/><deff>
Sets the halved at property. 
The properties <var>halved</var> and <var>halved at</var> are for stacking purposes and define in a stack of n fibers the number of fibers that are half the size of the other fibers (a second fiber is then filling up the space) and the element number when the halved elements first occur.  
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A HREF="volumeshape.html">volumeShape*</A> <A NAME="f10">fiber::getNext</A>(<vtype>int</vtype> times, <vtype>int</vtype> stackType) 
<BR/><deff>
Returns a new volume shape, that is shifted, rotated, shrunk, enlarged, or else modified according to the parameter <var>stackType</var>, generating the <var>times<sup>th</sup></var> element in the stack.     
Take care, that you delete this shape correctly after use (potential memory leak).     
<br>These stack types have been implemented:   
<br><table><tr><td><img src="images/fiber_rectangular.jpg"><td><img src="images/fiber_extended.jpg">   
<tr><td>rectangular stacking(2)<td>extended rectangular stacking (17)   
</table>   
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A HREF="volumeshape.html">volumeShape*</A> <A NAME="f11">fiber::getEnvelope</A>(<vtype>int</vtype> times, <vtype>int</vtype> stackType) 
<BR/><deff>
Returns a volume shape, that will be the envelope of <var>times</var> shapes, generated with the getNext-method in stack mode <var>stackType</var>.     
Take care, that you delete this shape correctly after use (potential memory leak).     
<br>These stack types have been implemented:   
<br><table><tr><td><img src="images/fiber_rectangular.jpg"><td><img src="images/fiber_extended.jpg">   
<tr><td>rectangular stacking(2)<td>extended rectangular stacking (17)   
</table>   
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A HREF="vector3d.html">vector3D</A> <A NAME="f12">fiber::distance</A>(const <A HREF="sline3d.html">sLine3D&</A> line) 
<BR/><deff>
Returns the distance vector from the straight line to the shape.   
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A HREF="sline3d.html">sLine3D</A> <A NAME="f13">fiber::Normal</A>(const <A HREF="sline3d.html">sLine3D&</A> line) 
<BR/><deff>
Returns the hit point of a straigt line with the shape and normal vector of the shape in that point. This is stored in the straight line return value with the Foot-property being the hit point and the Direction-property the normal vector.   
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A HREF="vector.html">Vector</A> <A NAME="f14">fiber::Hitting</A>(const <A HREF="sline3d.html">sLine3D&</A> line) 
<BR/><deff>
Calculates all characteristics of a hit of a straight line with the volume shape. The return values components will be:   
<table> 
<tr><th>index <th>value   
<tr><td>0, 1, 2 <td>entrance point of line   
<tr><td>3, 4, 5 <td>distance of line to volume, points to volume   
<tr><td>6, 7, 8 <td>normal vector to volume in entrance point   
<tr><td>9 <td>sigma value   
</table>   
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f15"><vtype>bool</vtype> fiber::cut</A>(const <A HREF="fiber.html">fiber&</A> f) 
<BR/><deff>
Returns true, if the shape and the fiber occupy some space commonly.   
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f16"><vtype>void</vtype> fiber::operator=</A>(const <A HREF="volumeshape.html">volumeShape&</A> s) 
<BR/><deff>
Copy operator. Only works if the shape is a fiber. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A HREF="volumeshape.html">volumeShape*</A> <A NAME="f17">fiber::getClone</A>() 
<BR/><deff>
Creates a new instance of the same volume shape with the same properties. Take care, that you delete this shape correctly after use (potential memory leak).   
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A HREF="vector.html">Vector</A> <A NAME="f18">fiber::HitParams</A>(const <A HREF="sline3d.html">sLine3D&</A> line) 
<BR/><deff>
Returns the parameters for a hit of a straight line with the shape. The pattern will be:     
<table>  
<tr><th>index of return<th>description     
<tr><td>0<td>sigma value     
<tr><td>1,2,3<td>entrance point of line/point on line closest to the volume     
<tr><td>4,5,6<td>resolution vector     
<tr><td>7,8,9<td>point on volume closest to the line     
<tr><td>10,11,12<td>minimum distance of line to volume, points to volume     
</table>     
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A HREF="vector.html">Vector</A> <A NAME="f19">fiber::HitParams</A>(const <A HREF="planeshape.html">planeShape&</A> shape, <A HREF="point3d.html">point3D</A> origin) 
<BR/><deff>
Returns the parameters for a hit of a pyramid like shape with the tip at <var>origin</var> and the <var>shape</var> as base with the shape. The pattern will be:        
<table>    
<tr><th>index of return<th>description      
<tr><td>0<td>sigma value      
<tr><td>1,2,3<td>entrance point of line/point on line closest to the volume      
<tr><td>4,5,6<td>resolution vector      
<tr><td>7,8,9<td>point on volume closest to the line      
<tr><td>10,11,12<td>minimum distance of line to volume, points to volume      
</table>        
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A HREF="point3d.html">point3D</A> <A NAME="f20">fiber::entrance</A>(const <A HREF="sline3d.html">sLine3D&</A> line) 
<BR/><deff>
Returns the entrance point of the straight line into the shape. This point is undefined if the line does not hit the shape.    
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f21"><vtype>float</vtype> fiber::getFlightPathInShape</A>(const <A HREF="sline3d.html">sLine3D&</A> line) 
<BR/><deff>
Calculates the entrance point and the exit point of the <var>line</var> in the shape and returns the length of the distance of the two points.    
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f22"><vtype>int</vtype> fiber::suspect</A>(const <A HREF="sline3d.html">sLine3D&</A> line, <vtype>int</vtype> stackType) 
<BR/><deff>
Assuming, this fiber is the first one in a stack of shapes generated with the getNext-method in stacking type <var>stackType</var>.     
Then the straight line <var>line</var> will hit the stack in the element number, that is returned or -1 if it doesn't hit the stack.    
This doesn't know about the actual number of elements in this stack, so you'll have to check if the return value exceeds this.    
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f23"><vtype>void</vtype> fiber::Draw</A>(const <A HREF="point3d.html">point3D&</A> eye, const <A HREF="plane3d.html">plane3D&</A> plane, <A HREF="vector4d.html">vector4D*</A> boundingBox, <vtype>int</vtype> lColor, <vtype>int</vtype> fColor = 8, <vtype>int</vtype> fStyle = 1001) const
<BR/><deff>
This function is used for drawing a shape to a root-TCanvas.    
It will draw a projection of the 3D shape from the <var>eye</var>-point to a <var>plane</var>. The corners of the drawn shape in canvas coordinates are stored in <var>boundingBox</var>. It is drawn using <var>lColor</var> as line color, <var>fColor</var> as fill color and <var>fStyle</var> as fill style. See <a href="http://root.cern.ch/root/html/TAttFill.html"> root-colors and -styles</a>.    
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f24"><vtype>void</vtype> fiber::Draw</A>(const <A HREF="point3d.html">point3D&</A> eye = point3D(0,0,0), const <A HREF="plane3d.html">plane3D&</A> plane = plane3D(point3D(0,0,1),vector3D(0,0,1)), <A HREF="vector4d.html">vector4D*</A> boundingBox = NULL, <A HREF="tobject.html">TObject**</A> ident = NULL, <vtype>int</vtype> lColor = 1, <vtype>int</vtype> fColor = 8, <vtype>int</vtype> fStyle = 1001) const
<BR/><deff>
This function is used for drawing a shape to a root-TCanvas.    
It will draw a projection of the 3D shape from the <var>eye</var>-point to a <var>plane</var>. The corners of the drawn shape in canvas coordinates are stored in <var>boundingBox</var>.    
It is drawn using <var>lColor</var> as line color, <var>fColor</var> as fill color and <var>fStyle</var> as fill style. See <a href="http://root.cern.ch/root/html/TAttFill.html"> root-colors and -styles</a>.    
The parameter <var>ident</var> will return a pointer to the drawn root-primitive to provide the distance-to-primitive functionality.   
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A HREF="shapeparameter.html">shape_parameter</A> <A NAME="f25">fiber::description</A>() const
<BR/><deff>
Returns a parameter with the values of this shape.
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A HREF="shapeparameter.html">shape_parameter</A> <A NAME="f26">fiber::getDescription</A>() 
<BR/><deff>
Static Method. Returns a default parameter with all necessary variables defined.
</deff>
<BR/><ttop><a href="#top">top</a></ttop>
</UL>
<hr><table width="30%"><tr><td>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img
alt="Creative Commons License" style="border-width:0"
src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a><br />This
work is licensed under a <a rel="license"
href="http://creativecommons.org/licenses/by-nc-sa/3.0/">cc by-nc-sa 3.0
Unported License</a> unless marked otherwise.</td></tr></table>
</body>
</html>
