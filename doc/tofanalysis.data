tofAnalysis
tofanalysis.html
/users/data12/pion/ehrhardt/tofPack2/include/tofAnalysis_t.h
CtofAnalysis
-1 tofAnalysis
O#c2
Pmax
0 int
V100
=
PmaxDets
0 int
V100
=
PNThreads
0 int
V1
=
DConstructor. Sets the maximum number of hits, pixels, clusters and tracks (per detector or ID) to <var>max</var> (default = 100) and the maximum number of IDs or detectors to <var>maxDet</var> (default = 100).
DThe number of parallel processes is set to <var>NThreads</var>. Don't set it to a number larger than the number of processors in your machine. It won't break, but there will only be a speed decrease.
=
gids
-1 vector<bool>
Sstatic
O#v2
D
=
gcurrID
0 int
Sstatic
O#v3
D
=
gmaxAlgorithms
0 int
Sconst
O#v4
D
=
gnThreads
0 int
Sconst
O#v5
D
=
gcount_mutex
-1 pthread_mutex_t
O#v6
D
=
gtcount_mutex
-1 pthread_mutex_t
O#v7
D
=
ginput_mutex
-1 pthread_mutex_t
O#v8
D
=
ghisto_mutex
-1 pthread_mutex_t
O#v9
D
=
gcount
0 int
O#v10
D
=
gtCount
0 int
O#v11
D
=
gthreadID
0 int*
O#v12
D
=
gnumAlgorithms
0 int
O#v13
D
=
gnumberOfEventsToAnalyse
0 int
O#v14
D
=
gEvent
105 TEvent*
O#v15
D
=
gSetup
108 TSetup
O#v16
D
=
gNumberOfHits
0 int***
O#v17
D
=
gNumberOfTracks
0 int**
O#v18
D
=
gNumberOfPixels
0 int***
O#v19
D
=
gNumberOfClusters
0 int***
O#v20
D
=
gNumberOfHitClusters
0 int***
O#v21
D
=
gRaws
100 TRawHit****
O#v22
D
=
gCalibratedHits
101 TCalibHit****
O#v23
D
=
gHitClusters
-1 THitCluster****
O#v24
D
=
gTracks
102 TTrack***
O#v25
D
=
gPixels
103 TPixel****
O#v26
D
=
gClusters
104 TCluster****
O#v27
D
=
gParticles
20 momentum4D***
O#v28
D
=
gmaxOfCalibratedHits
0 int
O#v29
D
=
gmaxOfPixels
0 int
O#v30
D
=
gmaxOfClusters
0 int
O#v31
D
=
gmaxOfTracks
0 int
O#v32
D
=
gNumberOfMaterials
0 int
O#v33
D
=
gNumberOfDetectors
0 int
O#v34
D
=
gMaterials
106 TMaterial**
O#v35
D
=
gDetectors
107 TDetector**
O#v36
D
=
gf
111 AAlgorithm***
O#v37
D
=
gfits
-1 AFitAlgorithm***
O#v38
D
=
gwaitFor
6 bool*
O#v39
D
=
gisInitD
6 bool
O#v40
D
=
gisInitA
6 bool
O#v41
D
=
gisInitS
6 bool
O#v42
D
=
gdataInput
-1 ifstream*
O#v43
D
=
grootFile
-1 TFile**
O#v44
D
=
gnumOfHitsInEvent
0 int
O#v45
D
=
greadInID
0 int
O#v46
D
=
ginputParameter
-1 vector<string>
O#v47
D
=
gruns
-1 vector<run_parameter>
O#v48
D
=
gbts
-1 vector<beamTime_parameter>
O#v49
D
=
gshowFrequency
0 int
O#v50
D
=
gsingle
6 bool
O#v51
D
=
greadInValid
6 bool
O#v52
D
=
grun
6 bool
O#v53
D
=
gcallEventSearch
6 bool
O#v54
D
=
FclassName
5 char*
Svirtual const
O#f2
DThe className() function that returns the class name as a string at runtime, 
Dwithout requiring native runtime type information (RTTI) support through the C++ compiler.
=
Finherrits
6 bool
Sconst
O#f3
Pclname
5 char*
Sconst
=
Dthe inherits() function that returns whether an object is an instance of a class 
Dthat inherits a specified class within the QObject inheritance tree. 
=
Ftr
-1 QString
Sstatic
O#f4
PsourceText
5 char*
Sconst
=
Pcomment
5 char*
Sconst
=
DReturns a translated version of sourceText, or sourceText itself if there is no 
Dappropriate translated version. The translation context is QObject with comment 
D(0 by default). All QObject subclasses using the Q_OBJECT macro automatically have 
Da reimplementation of this function with the subclass name as context.
DWarning: This method is reentrant only if all translators are installed before calling 
Dthis method. Installing or removing translators while performing translations is not 
Dsupported. Doing so will probably result in crashes or other undesirable behavior. 
=
FtrUtf8
-1 QString
Sstatic
O#f5
PsourceText
5 char*
Sconst
=
Pcomment
5 char*
Sconst
=
DReturns a translated version of sourceText, or QString::fromUtf8(sourceText) if there 
Dis no appropriate version. It is otherwise identical to tr(sourceText, comment). 
DWarning: This method is reentrant only if all translators are installed before calling 
Dthis method. Installing or removing translators while performing translations is not 
Dsupported. Doing so will probably result in crashes or other undesirable behavior. 
=
FsetProperty
6 bool
Svirtual
O#f6
Pname
5 char*
Sconst
=
Pvalue
-1 QVariant&
Sconst
=
DSets the value of the object's name property to value.
DReturns TRUE if the operation was successful; otherwise returns FALSE. 
DInformation about all available properties is provided through the metaObject()
=
Fproperty
-1 QVariant
Svirtual
O#f7
Lconst
Pname
5 char*
Sconst
=
DReturns the value of the object's name property. 
DIf no such property exists, the returned variant is invalid. 
DInformation about all available properties are provided through the metaObject(). 
=
FmetaObject
-1 QMetaObject*
Svirtual
O#f8
Lconst
DReturns a pointer to the meta object of this object. 
DA meta object contains information about a class that inherits QObject, e.g. class name,
Dsuperclass name, properties, signals and slots. Every class that contains the 
DQ_OBJECT macro will also have a meta object. 
DThe meta object information is required by the signal/slot connection mechanism 
Dand the property system. The functions isA() and inherits() also make use of the meta object. 
=
FclassName
5 char*
Svirtual const
O#f9
DThe className() function that returns the class name as a string at runtime, 
Dwithout requiring native runtime type information (RTTI) support through the C++ compiler.
=
Finherrits
6 bool
Sconst
O#f10
Pclname
5 char*
Sconst
=
Dthe inherits() function that returns whether an object is an instance of a class 
Dthat inherits a specified class within the QObject inheritance tree. 
=
Ftr
-1 QString
Sstatic
O#f11
PsourceText
5 char*
Sconst
=
Pcomment
5 char*
Sconst
=
DReturns a translated version of sourceText, or sourceText itself if there is no 
Dappropriate translated version. The translation context is QObject with comment 
D(0 by default). All QObject subclasses using the Q_OBJECT macro automatically have 
Da reimplementation of this function with the subclass name as context.
DWarning: This method is reentrant only if all translators are installed before calling 
Dthis method. Installing or removing translators while performing translations is not 
Dsupported. Doing so will probably result in crashes or other undesirable behavior. 
=
FtrUtf8
-1 QString
Sstatic
O#f12
PsourceText
5 char*
Sconst
=
Pcomment
5 char*
Sconst
=
DReturns a translated version of sourceText, or QString::fromUtf8(sourceText) if there 
Dis no appropriate version. It is otherwise identical to tr(sourceText, comment). 
DWarning: This method is reentrant only if all translators are installed before calling 
Dthis method. Installing or removing translators while performing translations is not 
Dsupported. Doing so will probably result in crashes or other undesirable behavior. 
=
FsetProperty
6 bool
Svirtual
O#f13
Pname
5 char*
Sconst
=
Pvalue
-1 QVariant&
Sconst
=
DSets the value of the object's name property to value.
DReturns TRUE if the operation was successful; otherwise returns FALSE. 
DInformation about all available properties is provided through the metaObject()
=
Fproperty
-1 QVariant
Svirtual
O#f14
Lconst
Pname
5 char*
Sconst
=
DReturns the value of the object's name property. 
DIf no such property exists, the returned variant is invalid. 
DInformation about all available properties are provided through the metaObject(). 
=
FmetaObject
-1 QMetaObject*
Svirtual
O#f15
Lconst
DReturns a pointer to the meta object of this object. 
DA meta object contains information about a class that inherits QObject, e.g. class name,
Dsuperclass name, properties, signals and slots. Every class that contains the 
DQ_OBJECT macro will also have a meta object. 
DThe meta object information is required by the signal/slot connection mechanism 
Dand the property system. The functions isA() and inherits() also make use of the meta object. 
=
F~tofAnalysis
-1 ~tofAnalysis
O#f16
DDestructor
=
Fprocess
6 bool
O#f17
DDoes analysis until all input is read.
=
FinitStep
7 void
O#f18
Pp
-1 vector<algorithm_parameter>&
Sconst
=
PbeamParam
-1 vector<beamTime_parameter>&
=
PrunParam
-1 vector<run_parameter>&
=
Pdets
-1 vector<detector_parameter>&
=
Pmats
-1 vector<material_parameter>&
=
Pcol
123 reaction_parameter
=
DInitializes the complete analysis. The setup is defined with <var>col</var> describing the reaction properties, <var>dets</var> the detectors, <var>mats</var> the materials.
DThe algorithms are initialized (see <a href="#f14">initAlgorithms()</a>. and the <var>beamParam</var> and <var>runParam</var> are initializing the data and calibration for read in.
=
Fstep
6 bool
O#f19
Pnum
0 int
V1
=
DDo <var>num</var> events in analysis. Stops if no data is left to read.
=
FendStep
7 void
O#f20
DKills all data, algorithms and such. Done before finally leaving the analysis.
=
FinitAlgorithms
7 void
O#f21
Pp
-1 vector<algorithm_parameter>&
Sconst
=
PrunParam
126 run_parameter&
Sconst
=
DInitializes the algorithms used in the analysis. In principle it is a giant switch-command taking the ID of the parameter <var>p</var> for all of the algorithms.
DHere the algorithms-constructors are called, the data structures are passed.
DAt the end, the <a href="#s2">newRun</a> signal is emitted.
=
FkillAlgorithms
7 void
O#f22
DDeletes the algorithms used in the analysis. Here the destructor is called. In many an algorithm the write-to-file is done here!
=
FinitData
7 void
O#f23
DInitializes the Data structures for analysis.
=
FkillData
7 void
O#f24
DDeletes the Data-structures for the analysis.
=
FgetVShape
151 volumeShape*
Sstatic
O#f25
Psh
129 shape_parameter&
=
DStatic method. Takes a shape_parameter and converts it into a volumeShape of the appropriate type. Has to be modified if new shapes are defined.
=
FdefineMaterials
7 void
O#f26
PfileName
-1 string&
Sconst
=
PfileName2
-1 string&
Sconst
=
DReads the material parameters from file <var>fileName2</var> and creates the materials as described. It also reads the setupdescription from <var>fileName</var> to assign the correct materials to the detectors.
=
FdefineMaterials
7 void
O#f27
Pmats
-1 vector<material_parameter>&
=
Pdets
-1 vector<detector_parameter>&
=
DDefines the materials according to the material describtions <var>mats</var> and assigns them to the detectors.
=
FdefineDetectors
7 void
O#f28
PfileName
-1 string&
Sconst
=
DReads the detector parameters from file <var>fileName</var> and creates the detectors according to the description.
=
FdefineDetectors
7 void
O#f29
Pdets
-1 vector<detector_parameter>&
=
DDefines the detectors as described by <var>dets</var>.
=
FdefineReaction
7 void
O#f30
Pcol
123 reaction_parameter
=
DDefines the reaction properties according to the reaction parameter <var>col</var>.
=
FcreateSetup
7 void
O#f31
Pdets
-1 vector<detector_parameter>&
=
Pmats
-1 vector<material_parameter>&
=
Pcol
123 reaction_parameter
=
DCreates a setup out of the detectors parameterized by <var>dets</var>, the materials by <var>mats</var> and the reaction properties <var>col</var>.
=
FcreateSetup
7 void
O#f32
PsetupFileName
-1 string&
Sconst
=
PmaterialFileName
-1 string&
Sconst
=
DCreates a setup by reading a setup-file and a material-file.
=
FkillSetup
7 void
O#f33
DDestroys the detector setup. All shapes, materials, and detectors are deleted.
=
Fthread_run
7 void*
O#f34
Pptr
7 void*
=
DRuns a thread. <font color="red">Do not call. Will be called from inside the class. Would have been private, but that was not possible out of technical reasons</font>
=
FgetHistogramNames
-1 vector<vector<string> >
O#f35
DReturns the histogram names of the histograms that have been defined by the algorithms in the analysis. Note that the first element in the vector-elements are the algorithm name.
=
FgetHisto
-1 TH1*
O#f36
Pname
-1 string&
Sconst
=
DReturns a pointer to the histogram of name <var>name</var> defined in one of the algorithms. Returns NULL if no such histogram has been defined.
=
FgetTreeNames
-1 vector<vector<string> >
O#f37
DReturns the names of the TTree-variables that are defined in the algorithms of the analysis. The first element of each vector-element is the algorithm name.
=
FgetTree
-1 TTree*
O#f38
Pname
-1 string&
Sconst
=
DReturns the TTree-variable of name <var>name</var>, that was defined by one of the algorithms. Returns NULL if no such tree has been declared.
=
FgetVariables
-1 vector<string>
Sstatic
O#f39
DStatic method. Returns a vector of strings. Each three following elements define a variable. First is the variable name, second its type and the third one defines the binding.
=
FgetTheTypes
-1 vector<string>
Sstatic
O#f40
Dobsolete. Static method for retrieving the types of the variables the class defines for the analysis.
=
FgetTheVID
-1 vector<int>
Sstatic
O#f41
Dobsolete. Static method to retrieve the binding of the variables defined in the class for analysis purpurses.
=
FgetID
0 int
Sstatic
O#f42
Dobsolete. Static method. Returns the currently new ID for a new algorithm.
=
FnewID
7 void
Sstatic
O#f43
Dobsolete. Static method. Generates a possible new ID for a new algorithm.
=
Finit
7 void
Sstatic
O#f44
DStatic method to init the IDs. obsolete!
=
FgetAlgorithmParameter
121 algorithm_parameter
Sstatic
O#f45
PID
0 int
=
DDepending on the ID, the result of the <a href="aalgorithm.html#f9">static getDescription()</a> of the corresponding installed algorithm is returned.
=
FgetAlgorithm
0 int
Sstatic
O#f46
Pout
111 AAlgorithm***
=
PexecuteUpTo
0 int&
=
Pparam
121 algorithm_parameter&
Sconst
=
PfirstRun
126 run_parameter&
Sconst
=
Pevent
105 TEvent&
=
Psetup
108 TSetup&
=
PnumberOfHits
0 int**
=
PnumberOfTracks
0 int*
=
PnumberOfPixels
0 int**
=
PnumberOfClusters
0 int**
=
PnumberOfHitClusters
0 int**
=
Praws
100 TRawHit***
=
PcalibratedHits
101 TCalibHit***
=
PhitClusters
-1 THitCluster***
=
Ptracks
102 TTrack**
=
Ppixels
103 TPixel***
=
Pclusters
104 TCluster***
=
Pmaterials
106 TMaterial**
=
Pdetectors
107 TDetector**
=
PreadValid
6 bool&
=
PreadInID
0 int&
=
PstearIt
-1 QObject*
=
PeventRequesting
6 bool&
=
DStatic method. This is the main Algorithm defining method. It contains the huge switch-call to decide on the ID of the parameter which algorithm to initialize. It returns the total number of algorithms allocated.
DIn <var>out</var> these algorithms are saved. Delete them after use.
D<var>executeUpTo</var> gives the number of algorithms that should be called in the event-loop, the rest can be such things as fitting algorithms. Apart from the data-structures, there are <var>readValid</var> that is given to reading-algorithms that will switch it to false if the number of remaining events for the current file is zero, <var>readInID</var> which is obsolete but kept for backward comptability, <var>stearIt</var> the class, that provides the essential signals for e.g. new runs, <var>eventRequesting</var> that provides a switch, that of several different reading algorithms one (not necessarily the first one) can act as an event-input-list.
=
FstopAnalysis
0 int
O#f47
DStops the analysis. The number of processed events is returned. 
DActually, the analysis will stop, when the last algorithm for this event has finished.
=
GgetAlgorithm
0 int
O#f48
Pparam
121 algorithm_parameter&
Sconst
=
PfirstRun
126 run_parameter&
Sconst
=
Pposition
0 int
=
PpositionFit
0 int
=
PnFits
0 int&
=
D
=
LaddRun
7 void
O#l2
Prp
126 run_parameter&
Trunparameter.html
=
DAdds a run to the list of runs to process.
=
LremoveRun
7 void
O#l3
Prp
126 run_parameter&
Trunparameter.html
=
DRemove run <var>rp</var> from the list of runs to process. Does nothing if <var>rp</var> is not in the list.
=
LaddRun
7 void
O#l4
Prp
126 run_parameter&
=
DAdds a run to the list of runs to process.
=
LremoveRun
7 void
O#l5
Prp
126 run_parameter&
=
DRemove run <var>rp</var> from the list of runs to process. Does nothing if <var>rp</var> is not in the list.
=
LdoRequestEvent
7 void
O#l6
PeventNumber
0 int
=
PrunNumber
0 int
=
DEmit the requestEvent-Signal, that can be caught by an input algorithm.
=
LdoRequestNextEvent
7 void
O#l7
DEmit the requestNextEvent-Signal, that can be caught by an input algorithm.
=
LshowNewRun
7 void
O#l8
Prun
126 run_parameter&
=
DDebugging output. Writes Run information to analysisLog.
=
NnewRun
7 void
O#s2
Pr
126 run_parameter&
Trunparameter.html
=
Pb
125 beamTime_parameter&
Tbeamtimeparameter.html
=
DThis signal is emitted, whenever a run has been read and a new one is due. It passes the new run <var>r</var> and its beam-time <var>b</var>.
=
NnewEvent
7 void
O#s3
PnrEvent
0 int
=
DThis signal is emitted, when an event has been processed. If you chose to analyse a single event it will be emitted after this, but if the number of events is large, it is only emitted all "showFrequency" events.<br>
DThis is 10000 if no more than 4 algorithms have been defined, 1000 else. Some algorithms also modify this value.
DFor single event mode, the event-number is passed, the number of processed events else.
=
NchangeEvent
7 void
O#s4
Pev
105 TEvent*
Ttmp.html
=
DThis signal is emitted, when an event has been processed. If you chose to analyse a single event it will be emitted after this, but if the number of events is large, it is only emitted all "showFrequency" events.<br>
DThis is 10000 if no more than 4 algorithms have been defined, 1000 else. Some algorithms also modify this value.
D<br>The complete event-structure is passed when called. Do not modify it. Others do perhaps also want to use it.
=
NalgorithmInit
7 void
O#s5
PalgoID
0 int
=
DSignal that is emitted, when an algorithm is going to be initialized. <var>algoID</var> is the position of the algorithm in the array.
=
NalgorithmInited
7 void
O#s6
PalgoID
0 int
=
DSignal that is emitted, when an algorithm has been initialized. <var>algoID</var> is the position of the algorithm in the array.
=
NanalysisFinished
7 void
O#s7
PnumEvents
0 int
=
DSignal that is emitted, when the analysis finished (because of reached maximum of events to process or read in is no longer valid). The parameter <var>numEvents</var> will hold the number of events that have been processed.
=
NinitStateChanged
7 void
O#s8
Pmsg
5 char*
Sconst
=
DThis signal is emitted, whenever a new algorithm is going to be initialized, the data-structures, setup etc are being created.
=
NnewRun
7 void
O#s9
Pr
126 run_parameter&
=
Pb
125 beamTime_parameter&
=
DThis signal is emitted, whenever a run has been read and a new one is due. It passes the new run <var>r</var> and its beam-time <var>b</var>.
=
NnewEvent
7 void
O#s10
PnrEvent
0 int
=
DThis signal is emitted, when an event has been processed. If you chose to analyse a single event it will be emitted after this, but if the number of events is large, it is only emitted all "showFrequency" events.<br>
DThis is 10000 if no more than 4 algorithms have been defined, 1000 else. Some algorithms also modify this value.
DFor single event mode, the event-number is passed, the number of processed events else.
=
NchangeEvent
7 void
O#s11
Pev
105 TEvent*
=
DThis signal is emitted, when an event has been processed. If you chose to analyse a single event it will be emitted after this, but if the number of events is large, it is only emitted all "showFrequency" events.<br>
DThis is 10000 if no more than 4 algorithms have been defined, 1000 else. Some algorithms also modify this value.
D<br>The complete event-structure is passed when called. Do not modify it. Others do perhaps also want to use it.
=
NalgorithmInit
7 void
O#s12
PalgoID
0 int
=
DSignal that is emitted, when an algorithm is going to be initialized. <var>algoID</var> is the position of the algorithm in the array.
=
NalgorithmInited
7 void
O#s13
PalgoID
0 int
=
DSignal that is emitted, when an algorithm has been initialized. <var>algoID</var> is the position of the algorithm in the array.
=
NanalysisFinished
7 void
O#s14
PnumEvents
0 int
=
DSignal that is emitted, when the analysis finished (because of reached maximum of events to process or read in is no longer valid). The parameter <var>numEvents</var> will hold the number of events that have been processed.
=
NinitStateChanged
7 void
O#s15
Pmsg
5 char*
Sconst
=
DThis signal is emitted, whenever a new algorithm is going to be initialized, the data-structures, setup etc are being created.
=
NfinishStateChanged
7 void
O#s16
Pmsg
5 char*
Sconst
=
DSignal emitted when a part of the finalisation is finished. Which one is given in <var>msg</var>.
=
NrequestEvent
7 void
O#s17
Peventnumber
0 int
=
Prunnumber
0 int
=
DRequests a specific event. Should be cought by an input algorithm.
=
NrequestNextEvent
7 void
O#s18
DRequests the next Event in queue. Should be cought by an input algorithm.
=
S0 0 QObject
http://doc.trolltech.com/4.4/qobject.html
=
