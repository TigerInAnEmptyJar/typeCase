<HTML>
<link rel="stylesheet" type="text/css" href="mystylesheet.css"/>
<HEAD>
<TITLE>Class TDetector</TITLE>
</HEAD>
<BODY>
<H1><A NAME="top">Class TDetector in "detector.h"</A></H1>
<P> <a href="">back</a>
<hr/>
<DL>
<DT>Superclass
<DD><A HREF="tbase.html">TBase</A>
<DT>Constructor
<LI><A HREF="#c2">TDetector</A>(<A HREF="tmaterial.html">TMaterial&</A> matIn, <vtype>int</vtype> detNumIn) 
<LI><A HREF="#c3">TDetector</A>(const <A HREF="tdetector.html">TDetector&</A> det) 
<LI><A HREF="#c4">TDetector</A>() 
<DT>Functions
<DD>new public<ul>
<LI><A HREF="#f2">~TDetector</A>() 
<LI><A HREF="#f3"><vtype>int</vtype> getDetectorNumber</A>() const
<LI><A HREF="#f4"><vtype>int</vtype> getStackType</A>() const
<LI><A HREF="#f5"><vtype>int</vtype> getNumberOfElements</A>() const
<LI><A HREF="#f6"><vtype>int</vtype> getID</A>() const
<LI><A HREF="#f7"><vtype>bool</vtype> isCircular</A>() const
<LI><A HREF="tmaterial.html">TMaterial*</A> <A HREF="#f8">getMaterial</A>() const
<LI><A HREF="volumeshape.html">volumeShape*</A> <A HREF="#f9">getOverallShape</A>() const
<LI><A HREF="volumeshape.html">volumeShape*</A> <A HREF="#f10">getShape</A>(<vtype>int</vtype> ElementNumber) const
<LI><A HREF="#f11"><vtype>void</vtype> setNumberOfElements</A>(<vtype>int</vtype> num) 
<LI><A HREF="#f12"><vtype>void</vtype> setStackType</A>(<vtype>int</vtype> st) 
<LI><A HREF="#f13"><vtype>void</vtype> setMaterial</A>(<A HREF="tmaterial.html">TMaterial&</A> m) 
<LI><A HREF="#f14"><vtype>void</vtype> setShapeFirstElement</A>(<A HREF="volumeshape.html">volumeShape*</A> sh) 
<LI><A HREF="#f15"><vtype>void</vtype> setShapes</A>(<vtype>int</vtype> n, <A HREF="volumeshape.html">volumeShape**</A> shapes) 
<LI><A HREF="#f16"><vtype>void</vtype> setCircular</A>(<vtype>bool</vtype> circ = true) 
<LI><A HREF="#f17"><vtype>void</vtype> operator=</A>(const <A HREF="tdetector.html">TDetector&</A> d) 
<LI><A HREF="#f18"><vtype>bool</vtype> isDefined</A>() const
</UL>
<DD>public inherrited<UL>
<LI><A HREF="tbase.html#f3"><vtype>string</vtype> TBase::name</A>() const
</UL>
<DT>Protected inherrited variables
<DD><vtype>string</vtype> <A HREF="tbase.html#v2">TBase::fname</A>
</DL>
<hr/>
<H2>Descriptions</H2>
<UL TYPE=square>
<li>
<A NAME="c2">TDetector::TDetector</A>(<A HREF="tmaterial.html">TMaterial&</A> matIn, <vtype>int</vtype> detNumIn) 
<BR/><deff>
Constructor. Defines the detectors material (Note that just a pointer and no copy of the material is saved), the maximum number of elements and the detector ID. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="c3">TDetector::TDetector</A>(const <A HREF="tdetector.html">TDetector&</A> det) 
<BR/><deff>
Copy constructor.
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="c4">TDetector::TDetector</A>() 
<BR/><deff>
Default constructor. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f2">TDetector::~TDetector</A>() 
<BR/><deff>
Destructor 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f3"><vtype>int</vtype> TDetector::getDetectorNumber</A>() const
<BR/><deff>
Returns the detector ID. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f4"><vtype>int</vtype> TDetector::getStackType</A>() const
<BR/><deff>
Returns the stack-type-property. It defines how the elements shapes are generated out of the first one.  
See the getNext()-method for the corresponding shape. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f5"><vtype>int</vtype> TDetector::getNumberOfElements</A>() const
<BR/><deff>
Returns the number of elements defined for the detector. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f6"><vtype>int</vtype> TDetector::getID</A>() const
<BR/><deff>
Returns the detectors ID. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f7"><vtype>bool</vtype> TDetector::isCircular</A>() const
<BR/><deff>
Returns true if the first elements shape neighbours the last one. There is no check done if this is really true and the property has to be set by the user. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A HREF="tmaterial.html">TMaterial*</A> <A NAME="f8">TDetector::getMaterial</A>() const
<BR/><deff>
Returns a pointer to the material the detector is made up. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A HREF="volumeshape.html">volumeShape*</A> <A NAME="f9">TDetector::getOverallShape</A>() const
<BR/><deff>
Returns the overall shape of the detector if for the detectors shapes a getEnvelope-routine is correctly implemented.  
Take care, that this pointer is correctly deleted after use. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A HREF="volumeshape.html">volumeShape*</A> <A NAME="f10">TDetector::getShape</A>(<vtype>int</vtype> ElementNumber) const
<BR/><deff>
Returns a pointer to the shape of the <var>ElementNumber<sup>th</sup></var> element. 
Returns NULL if <var>ElementNumber</var> is non-valid. 
Do not delete this pointer, it is the only one we've got. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f11"><vtype>void</vtype> TDetector::setNumberOfElements</A>(<vtype>int</vtype> num) 
<BR/><deff>
Sets the number of elements and creates new volume shapes for the detector elements. Advice, first set the number of elements and later the shape of the first element to save new and delete operations. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f12"><vtype>void</vtype> TDetector::setStackType</A>(<vtype>int</vtype> st) 
<BR/><deff>
Sets the stack type property of the detector elements. Defines how the shapes of the elements of the detector are generated out of the first one. For additional information see the getNext routine of the corresponding shape. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f13"><vtype>void</vtype> TDetector::setMaterial</A>(<A HREF="tmaterial.html">TMaterial&</A> m) 
<BR/><deff>
Sets the detectors material. Note that only a pointer is set and no copy is made: the material should persist in memory as long as it is used in the detector. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f14"><vtype>void</vtype> TDetector::setShapeFirstElement</A>(<A HREF="volumeshape.html">volumeShape*</A> sh) 
<BR/><deff>
Sets the shape of the first element. The pointer is saved and for all other elements the element volume shape is generated using the getNext() routine and the stackType property. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f15"><vtype>void</vtype> TDetector::setShapes</A>(<vtype>int</vtype> n, <A HREF="volumeshape.html">volumeShape**</A> shapes) 
<BR/><deff>
Sets all shapes of all detector-elements in one go. Use this if you don't want to use the getNext()-method, the shapes provide.
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f16"><vtype>void</vtype> TDetector::setCircular</A>(<vtype>bool</vtype> circ = true) 
<BR/><deff>
Sets the circular property. This tells weather the last elements neighbours the first one. It is an additional property without any consequences on element shape generation. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f17"><vtype>void</vtype> TDetector::operator=</A>(const <A HREF="tdetector.html">TDetector&</A> d) 
<BR/><deff>
Copy operator. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop><hr/>
<li>
<A NAME="f18"><vtype>bool</vtype> TDetector::isDefined</A>() const
<BR/><deff>
Returns true if the detector has been modified since its creation. 
</deff>
<BR/><ttop><a href="#top">top</a></ttop>
</UL>
<hr><table width="30%"><tr><td>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img
alt="Creative Commons License" style="border-width:0"
src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a><br />This
work is licensed under a <a rel="license"
href="http://creativecommons.org/licenses/by-nc-sa/3.0/">cc by-nc-sa 3.0
Unported License</a> unless marked otherwise.</td></tr></table>
</body>
</html>
